{
  "language": "Solidity",
  "sources": {
    "contracts/Splitwiser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ncontract Splitwiser {\n    struct Debt {\n        string name;\n        address debtor;\n        address creditor;\n        uint256 amount;\n        bool paid;\n    }\n\n    struct Group {\n        address[] members;\n        mapping(uint256 => Debt) debts;\n        uint256 nextDebtId;\n    }\n\n    struct PaymentToDo {\n        address creditor;\n        uint256 amount;\n    }\n\n    mapping(string => Group) public groups;\n    mapping(address => string[]) public pendingGroups;\n    mapping(address => mapping(string => int256)) public balances; // address => groupName => balance\n    mapping(address => mapping(string => PaymentToDo[])) paymentstodo; // address => groupName => payments ( creditor + amt )\n\n    event DebtAdded(string indexed groupName, uint256 indexed debtId, address indexed debtor, address creditor, uint256 amount, string name);\n\n    modifier onlyMember(string memory _groupName) {\n        require(isMember(_groupName, msg.sender), \"You are not a member of this group\");\n        _;\n    }\n\n    function acceptInvite(string memory _groupName) public {\n        string[] storage groupss = pendingGroups[msg.sender];\n        require(groupss.length > 0, \"No pending invites\");\n        for(uint i = 0; i < groupss.length; i++) {\n            if(keccak256(abi.encode(groupss[i])) == keccak256(abi.encode((_groupName)))){\n                delete pendingGroups[msg.sender][i];\n                groups[_groupName].members.push(msg.sender);\n            }\n        }\n    }\n\n    function createGroup(string memory _name, address[] memory _members) external {\n        require(_members.length > 1, \"Group must have at least 2 members\");\n        Group storage newGroup = groups[_name];\n        newGroup.members = _members;\n        newGroup.nextDebtId = 1;\n    }\n\n    function isMember(string memory _groupName, address _member) internal view returns (bool) {\n        address[] memory members = groups[_groupName].members;\n        for (uint i = 0; i < members.length; i++) {\n            if (members[i] == _member) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isPending(string memory _groupName, address _member) internal view returns (bool) {\n        for(uint i = 0; i < pendingGroups[_member].length; i++) {\n            if (keccak256(bytes(pendingGroups[_member][i])) == keccak256(bytes(_groupName))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function inviteMember(string memory _groupName, address _invited) public onlyMember(_groupName) {\n        require(!isPending(_groupName, _invited) && !isMember(_groupName, _invited), \"Member is already in (pending) group\");\n        pendingGroups[_invited].push(_groupName);\n    }\n\n    function removeInvite(string memory _groupName, address _invited) public onlyMember(_groupName) {\n        require(!isMember(_groupName, _invited), \"Member is already in group\");\n        string[] storage invites = pendingGroups[_invited];\n        for (uint i = 0; i < invites.length; i++) {\n            if (keccak256(bytes(invites[i])) == keccak256(bytes(_groupName))) {\n                invites[i] = invites[invites.length - 1];\n                invites.pop();\n                break;\n            }\n        }\n    }\n\n    function addDebt(string memory _groupName, address _creditor, uint256 _amount, string memory _name) external onlyMember(_groupName) {\n        require(_creditor != msg.sender, \"Cannot owe yourself\");\n        require(_amount > 0, \"Amount must be positive\");\n        require(isMember(_groupName, _creditor), \"Creditor must be a group member\");\n\n        _addDebt(_groupName, msg.sender, _creditor, _amount, _name);\n    }\n\n    function _addDebt(string memory _groupName, address _debitor, address _creditor, uint256 _amount, string memory _name) internal {\n        Group storage group = groups[_groupName];\n        uint256 debtId = group.nextDebtId++;\n        group.debts[debtId] = Debt(_name, _debitor, _creditor, _amount, false);\n\n        balances[_debitor][_groupName] -= int256(_amount);\n        balances[_creditor][_groupName] += int256(_amount);\n\n        emit DebtAdded(_groupName, debtId, _debitor, _creditor, _amount, _name);\n    }\n\n    function addExpense(string memory _groupName, address[] memory _creditors, uint256[] memory _amounts, string memory _name) external onlyMember(_groupName) {\n        require(_creditors.length == _amounts.length , \"Lenghts do not match\");\n        for(uint32 i=0; i<_creditors.length; i++){\n            _addDebt(_groupName, msg.sender, _creditors[i], _amounts[i], _name);\n        }\n    }\n\n    function findDebts(string memory _groupName, address _person) external view onlyMember(_groupName) returns (PaymentToDo[] memory){\n        return paymentstodo[_person][_groupName];\n    }\n\n    function payDebtsForGroup(string memory _groupName) external {\n        //TODO USDC INTEGRATION\n        PaymentToDo[]memory ptd = paymentstodo[msg.sender][_groupName];\n        for(uint32 i=0; i<ptd.length;i++) {\n            balances[msg.sender][_groupName] += int256(ptd[i].amount);\n            balances[ptd[i].creditor][_groupName] -= int256(ptd[i].amount);\n        }\n    }\n\n    function settleGroupDebts(string memory _groupName) payable external onlyMember(_groupName) {\n        Group storage group = groups[_groupName];\n        address[] memory members = group.members;\n        address[] memory debtors = new address[](members.length);\n        address[] memory creditors = new address[](members.length);\n        uint256 debtorCount = 0;\n        uint256 creditorCount = 0;\n        mapping(address => mapping(string => int256)) storage balances_temp = balances;\n\n        // Separate debtors and creditors\n        for (uint256 i = 0; i < members.length; i++) {\n            int256 balance = balances_temp[members[i]][_groupName];\n            if (balance < 0) {\n                debtors[debtorCount++] = members[i];\n            } else if (balance > 0) {\n                creditors[creditorCount++] = members[i];\n            }\n        }\n\n        sortAddresses(debtors, debtorCount, _groupName, true);\n        sortAddresses(creditors, creditorCount, _groupName, false);\n\n        uint256 debtorIndex = 0;\n        uint256 creditorIndex = 0;\n        while (debtorIndex < debtorCount && creditorIndex < creditorCount) {\n            address debtor = debtors[debtorIndex];\n            address creditor = creditors[creditorIndex];\n            uint256 amount = uint256(min(-int128(balances_temp[debtor][_groupName]), int128(balances_temp[creditor][_groupName])));\n\n            paymentstodo[debtor][_groupName].push(PaymentToDo(creditor, amount));\n\n            balances_temp[debtor][_groupName] += int256(amount);\n            balances_temp[creditor][_groupName] -= int256(amount);\n\n            emit DebtSettled(_groupName, debtor, creditor, amount);\n\n            if (balances_temp[debtor][_groupName] == 0) debtorIndex++;\n            if (balances_temp[creditor][_groupName] == 0) creditorIndex++;\n\n        }\n    }\n\n    function sortAddresses(address[] memory arr, uint256 count, string memory _groupName, bool isDebtors) internal view {\n        for (uint256 i = 0; i < count - 1; i++) {\n            for (uint256 j = 0; j < count - i - 1; j++) {\n                if (isDebtors) {\n                    if (balances[arr[j]][_groupName] > balances[arr[j + 1]][_groupName]) {\n                        (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n                    }\n                } else {\n                    if (balances[arr[j]][_groupName] < balances[arr[j + 1]][_groupName]) {\n                        (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n                    }\n                }\n            }\n        }\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    event DebtSettled(string indexed groupName, address indexed debtor, address indexed creditor, uint256 amount);\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}